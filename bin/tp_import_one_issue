#!/usr/bin/env ruby
# frozen_string_literal: true

require "json"

require_relative "../lib/tp_to_github"

dry_run = ENV["DRY_RUN"] == "1"
# NOTE: historically this flag was named "IDEMPOTEN" (without the trailing T).
# Support both spellings.
raw_idempotent = ENV.key?("IDEMPOTENT") ? ENV.fetch("IDEMPOTENT") : ENV.fetch("IDEMPOTEN", "1")

idempotent = raw_idempotent != "0"

repo = ENV.fetch("GITHUB_REPO")
access_token = ENV.fetch("GITHUB_ACCESS_TOKEN")
project_name = ENV["GITHUB_PROJECT_NAME"]

org = repo.split("/").first if repo.include?("/")
project_client = nil
project_node_id = nil
if project_name && org
  project_client = TpToGithub::GitHubProjectClient.new(access_token:, org: org)
  unless dry_run
    project_node_id = project_client.project_node_id_by_name(project_name)
  end
end

story_id = Integer(ENV.fetch("TP_STORY_ID"), 10)
base_url = ENV.fetch("TP_BASE_URL", "")
username = ENV.fetch("TP_USERNAME", "")
password = ENV.fetch("TP_PASSWORD", "")

repo = ENV.fetch("GITHUB_REPO")
access_token = ENV.fetch("GITHUB_ACCESS_TOKEN")
project_name = ENV["GITHUB_PROJECT_NAME"]

org = repo.split("/").first if repo.include?("/")

team_id = Integer(ENV.fetch("TP_TEAM_ID", "35411"), 10)

tp = TpToGithub::TargetProcessClient.new(base_url:, username:, password:)
github = TpToGithub::GitHubClient.new(access_token:, repo:)
normalizer = TpToGithub::StoryNormalizer.new(base_url:)
attachments_branch = ENV["GITHUB_BRANCH"]

uploader = TpToGithub::AttachmentUploader.new(tp_client: tp, github_client: github, repo:, branch: attachments_branch)

story = tp.user_story(id: story_id)
tasks = tp.tasks_for_user_story(story_id:, team_id:)

project_id = story.dig("Project", "Id")
feature_id = story.dig("Feature", "Id")
raise "Story is missing Project.Id" if project_id.nil?
raise "Story is missing Feature.Id" if feature_id.nil?

feature = tp.feature(id: feature_id)
epic_id = feature.dig("Epic", "Id")
raise "Feature is missing Epic.Id" if epic_id.nil?

epic = tp.epic(id: epic_id)
project = tp.project(id: project_id)

project_attachments = uploader.upload_attachments(tp_type: "Project", tp_entity_id: project_id, dry_run:)
epic_attachments = uploader.upload_attachments(tp_type: "Epic", tp_entity_id: epic_id, dry_run:)
feature_attachments = uploader.upload_attachments(tp_type: "Feature", tp_entity_id: feature_id, dry_run:)
story_attachments = uploader.upload_attachments(tp_type: "UserStory", tp_entity_id: story_id, dry_run:)

normalized_project = normalizer.normalize_entity(project, tp_type: "Project", attachments: project_attachments)
normalized_epic = normalizer.normalize_entity(epic, tp_type: "Epic", attachments: epic_attachments)
normalized_feature = normalizer.normalize_entity(feature, tp_type: "Feature", attachments: feature_attachments)
normalized_story = normalizer.normalize(story, tasks:, attachments: story_attachments)

plan = {
  "dry_run" => dry_run,
  "idempotent" => idempotent,
  "tp" => {
    "project" => { "id" => project_id, "name" => project["Name"], "attachment_count" => project_attachments.length },
    "epic" => { "id" => epic_id, "name" => epic["Name"], "attachment_count" => epic_attachments.length },
    "feature" => { "id" => feature_id, "name" => feature["Name"], "attachment_count" => feature_attachments.length },
    "story" => { "id" => story_id, "name" => story["Name"], "task_count" => tasks.length, "attachment_count" => story_attachments.length }
  },
  "github" => {
    "repo" => repo,
    "actions" => []
  }
}

def tp_to_github_issue_type(tp_type)
  case tp_type
  when "UserStory" then "Story"
  when "Epic" then "Epic"
  when "Feature" then "Feature"
  when "Project" then "Project"
  else nil # Or raise/warn as needed
  end
end

def create_or_find_issue(github:, tp_type:, tp_id:, title:, body:, created_issues:, plan_actions:, dry_run:, idempotent:, project_client: nil, project_node_id: nil, org: nil, repo: nil)
  if idempotent
    existing = github.find_issue_by_marker(tp_type:, tp_id:)

    if existing
      plan_actions << { "reuse_issue" => title }
      return existing
    end
  end

  plan_actions << { "create_issue" => title }
  return { "number" => -1, "id" => -1, "html_url" => "" } if dry_run

  issue_type = tp_to_github_issue_type(tp_type)
  created = github.create_issue(title: title, body: body, type: issue_type)
  created_issues << created

  # Add to GitHub Project v2 if requested
  if project_client && project_node_id && org && repo
    begin
      issue_number = created["number"]
      repo_name = repo.split("/").last
      issue_node = project_client.issue_node_id(owner: org, repo: repo_name, number: issue_number)
      project_item_id = project_client.add_item_to_project(project_node_id: project_node_id, issue_node_id: issue_node)
      created["project_item_id"] = project_item_id # pass for estimate step
      plan_actions << { "add_to_project_v2" => title }
    rescue => e
      plan_actions << { "add_to_project_v2_error" => { "title" => title, "error" => e.message } }
      warn "[tp-to-github] Failed to add issue to project: #{e.message}"
    end
  end

  created
end

plan_actions = []

created_issues = []

begin
  project_issue = create_or_find_issue(
    github:,
    tp_type: "Project",
    tp_id: project_id,
    title: normalized_project.fetch("name"),
    body: normalized_project.fetch("description_markdown"),
    created_issues:,
    plan_actions:,
    dry_run:,
    idempotent:,
    project_client: project_client,
    project_node_id: project_node_id,
    org: org,
    repo: repo
  )

  epic_issue = create_or_find_issue(
    github:,
    tp_type: "Epic",
    tp_id: epic_id,
    title: normalized_epic.fetch("name"),
    body: normalized_epic.fetch("description_markdown"),
    created_issues:,
    plan_actions:,
    dry_run:,
    idempotent:,
    project_client: project_client,
    project_node_id: project_node_id,
    org: org,
    repo: repo
  )

  plan_actions << { "add_sub_issue" => "Project -> Epic" }
  github.add_sub_issue(parent_issue_number: project_issue.fetch("number"), child_issue_id: epic_issue.fetch("id")) unless dry_run

  feature_issue = create_or_find_issue(
    github:,
    tp_type: "Feature",
    tp_id: feature_id,
    title: normalized_feature.fetch("name"),
    body: normalized_feature.fetch("description_markdown"),
    created_issues:,
    plan_actions:,
    dry_run:,
    idempotent:,
    project_client: project_client,
    project_node_id: project_node_id,
    org: org,
    repo: repo
  )

  plan_actions << { "add_sub_issue" => "Epic -> Feature" }
  github.add_sub_issue(parent_issue_number: epic_issue.fetch("number"), child_issue_id: feature_issue.fetch("id")) unless dry_run

  story_issue = create_or_find_issue(
    github:,
    tp_type: "UserStory",
    tp_id: story_id,
    title: normalized_story.fetch("name"),
    body: normalized_story.fetch("description_markdown"),
    created_issues:,
    plan_actions:,
    dry_run:,
    idempotent:,
    project_client: project_client,
    project_node_id: project_node_id,
    org: org,
    repo: repo
  )

  # Set Estimate field from TP Effort (if present)
  tp_effort = story["Effort"]
  if !tp_effort.nil? && project_client && project_node_id && org && repo
    begin
      repo_name = repo.split("/").last
      issue_node = project_client.issue_node_id(owner: org, repo: repo_name, number: story_issue["number"])
      # Use the add_to_project mutation result (should be the item_id)
      item_id = story_issue["project_item_id"] || begin
        # fallback if not present (should not happen for new items)
        project_client.find_project_item_id(project_node_id: project_node_id, issue_node_id: issue_node)
      end
      fields = project_client.project_fields(project_node_id: project_node_id)
      matches = fields.select { |f| f["name"] == "Estimate" && f["dataType"] == "NUMBER" }
      if matches.empty?
        raise "No project field named 'Estimate' of type NUMBER found"
      elsif matches.size > 1
        raise "Multiple 'Estimate' fields found, will not set value (ambiguous)"
      end
      field_id = matches.first["id"]
      if dry_run
        plan_actions << { "set_project_estimate" => { "item_id" => item_id, "field_id" => field_id, "value" => tp_effort } }
      else
        project_client.set_estimate_field(project_node_id: project_node_id, item_id: item_id, field_id: field_id, value: tp_effort)
        plan_actions << { "set_project_estimate" => { "item_id" => item_id, "field_id" => field_id, "value" => tp_effort } }
      end
    rescue => e
      plan_actions << { "set_project_estimate_error" => { "error" => e.message, "story_id" => story_id } }
      warn "[tp-to-github] Failed to set Estimate project field: #{e.message}"
    end
  end

  plan_actions << { "add_sub_issue" => "Feature -> Story" }
  github.add_sub_issue(parent_issue_number: feature_issue.fetch("number"), child_issue_id: story_issue.fetch("id")) unless dry_run

  if dry_run
    plan["github"]["actions"] = plan_actions
    puts JSON.pretty_generate(plan)
    exit 0
  end

  result = {
    "tp_story_id" => story_id,
    "tp_team_id" => team_id,
    "github_project_issue" => { "number" => project_issue["number"], "url" => project_issue["html_url"] },
    "github_epic_issue" => { "number" => epic_issue["number"], "url" => epic_issue["html_url"] },
    "github_feature_issue" => { "number" => feature_issue["number"], "url" => feature_issue["html_url"] },
    "github_story_issue" => { "number" => story_issue["number"], "url" => story_issue["html_url"] }
  }

  puts JSON.pretty_generate(result)
ensure
  created_issues.each do |issue|
    github.mute_issue(issue_number: issue.fetch("number"))
  rescue TpToGithub::GitHubClient::Error
    nil
  end
end
