#!/usr/bin/env ruby
# frozen_string_literal: true

require "json"

require_relative "../lib/tp_to_github"
require_relative "../lib/tp_to_github/assignee_utils"

dry_run = ENV["DRY_RUN"] == "1"
# NOTE: historically this flag was named "IDEMPOTEN" (without the trailing T).
# Support both spellings.
raw_idempotent = ENV.key?("IDEMPOTENT") ? ENV.fetch("IDEMPOTENT") : ENV.fetch("IDEMPOTEN", "1")

idempotent = raw_idempotent != "0"

repo = ENV.fetch("GITHUB_REPO")
access_token = ENV.fetch("GITHUB_ACCESS_TOKEN")
project_name = ENV["GITHUB_PROJECT_NAME"]

org = repo.split("/").first if repo.include?("/")
project_client = nil
project_node_id = nil
if project_name && org
  project_client = TpToGithub::GitHubProjectClient.new(access_token:, org: org)
  unless dry_run
    project_node_id = project_client.project_node_id_by_name(project_name)
  end
end

story_id = Integer(ENV.fetch("TP_STORY_ID"), 10)
base_url = ENV.fetch("TP_BASE_URL", "")
username = ENV.fetch("TP_USERNAME", "")
password = ENV.fetch("TP_PASSWORD", "")

repo = ENV.fetch("GITHUB_REPO")
access_token = ENV.fetch("GITHUB_ACCESS_TOKEN")
project_name = ENV["GITHUB_PROJECT_NAME"]

org = repo.split("/").first if repo.include?("/")

team_id = Integer(ENV.fetch("TP_TEAM_ID", "35411"), 10)

tp = TpToGithub::TargetProcessClient.new(base_url:, username:, password:)
github = TpToGithub::GitHubClient.new(access_token:, repo:)
normalizer = TpToGithub::StoryNormalizer.new(base_url:)
attachments_branch = ENV["GITHUB_BRANCH"]

uploader = TpToGithub::AttachmentUploader.new(tp_client: tp, github_client: github, repo:, branch: attachments_branch)

story = tp.user_story(id: story_id)
tasks = tp.tasks_for_user_story(story_id:, team_id:)

project_id = story.dig("Project", "Id")
feature_id = story.dig("Feature", "Id")
raise "Story is missing Project.Id" if project_id.nil?
raise "Story is missing Feature.Id" if feature_id.nil?

feature = tp.feature(id: feature_id)
epic_id = feature.dig("Epic", "Id")
raise "Feature is missing Epic.Id" if epic_id.nil?

epic = tp.epic(id: epic_id)
project = tp.project(id: project_id)

project_attachments = uploader.upload_attachments(tp_type: "Project", tp_entity_id: project_id, dry_run:)
epic_attachments = uploader.upload_attachments(tp_type: "Epic", tp_entity_id: epic_id, dry_run:)
feature_attachments = uploader.upload_attachments(tp_type: "Feature", tp_entity_id: feature_id, dry_run:)
story_attachments = uploader.upload_attachments(tp_type: "UserStory", tp_entity_id: story_id, dry_run:)

normalized_project = normalizer.normalize_entity(project, tp_type: "Project", attachments: project_attachments)
normalized_epic = normalizer.normalize_entity(epic, tp_type: "Epic", attachments: epic_attachments)
normalized_feature = normalizer.normalize_entity(feature, tp_type: "Feature", attachments: feature_attachments)
normalized_story = normalizer.normalize(story, tasks:, attachments: story_attachments)

plan = {
  "dry_run" => dry_run,
  "idempotent" => idempotent,
  "tp" => {
    "project" => { "id" => project_id, "name" => project["Name"], "attachment_count" => project_attachments.length },
    "epic" => { "id" => epic_id, "name" => epic["Name"], "attachment_count" => epic_attachments.length },
    "feature" => { "id" => feature_id, "name" => feature["Name"], "attachment_count" => feature_attachments.length },
    "story" => { "id" => story_id, "name" => story["Name"], "task_count" => tasks.length, "attachment_count" => story_attachments.length }
  },
  "github" => {
    "repo" => repo,
    "actions" => []
  }
}

def tp_to_github_issue_type(tp_type)
  case tp_type
  when "UserStory" then "Story"
  when "Epic" then "Epic"
  when "Feature" then "Feature"
  when "Project" then "Project"
  else nil # Or raise/warn as needed
  end
end

def create_or_find_issue(github:, tp_type:, tp_id:, title:, body:, created_issues:, plan_actions:, dry_run:, idempotent:, project_client: nil, project_node_id: nil, org: nil, repo: nil, assignees: nil)
  if idempotent
    existing = github.find_issue_by_marker(tp_type:, tp_id:)

    if existing
      plan_actions << { "reuse_issue" => title }
      return existing
    end
  end

  plan_actions << { "create_issue" => title }
  if dry_run
    plan_actions << { "assignees" => assignees } if assignees && tp_type == "UserStory"
    return { "number" => -1, "id" => -1, "html_url" => "" }
  end

  issue_type = tp_to_github_issue_type(tp_type)
  if tp_type == "UserStory"
    created = github.create_issue(title: title, body: body, type: issue_type, assignees: assignees)
  else
    created = github.create_issue(title: title, body: body, type: issue_type)
  end
  created_issues << created

  # Add to GitHub Project v2 if requested
  if project_client && project_node_id && org && repo
    begin
      issue_number = created["number"]
      repo_name = repo.split("/").last
      issue_node = project_client.issue_node_id(owner: org, repo: repo_name, number: issue_number)
      project_item_id = project_client.add_item_to_project(project_node_id: project_node_id, issue_node_id: issue_node)
      created["project_item_id"] = project_item_id # pass for estimate step
      plan_actions << { "add_to_project_v2" => title }
    rescue => e
      plan_actions << { "add_to_project_v2_error" => { "title" => title, "error" => e.message } }
      warn "[tp-to-github] Failed to add issue to project: #{e.message}"
    end
  end

  created
end

plan_actions = []

created_issues = []

begin
  project_issue = create_or_find_issue(
    github:,
    tp_type: "Project",
    tp_id: project_id,
    title: normalized_project.fetch("name"),
    body: normalized_project.fetch("description_markdown"),
    created_issues:,
    plan_actions:,
    dry_run:,
    idempotent:,
    project_client: project_client,
    project_node_id: project_node_id,
    org: org,
    repo: repo
  )

  epic_issue = create_or_find_issue(
    github:,
    tp_type: "Epic",
    tp_id: epic_id,
    title: normalized_epic.fetch("name"),
    body: normalized_epic.fetch("description_markdown"),
    created_issues:,
    plan_actions:,
    dry_run:,
    idempotent:,
    project_client: project_client,
    project_node_id: project_node_id,
    org: org,
    repo: repo
  )

  plan_actions << { "add_sub_issue" => "Project -> Epic" }
  github.add_sub_issue(parent_issue_number: project_issue.fetch("number"), child_issue_id: epic_issue.fetch("id")) unless dry_run

  feature_issue = create_or_find_issue(
    github:,
    tp_type: "Feature",
    tp_id: feature_id,
    title: normalized_feature.fetch("name"),
    body: normalized_feature.fetch("description_markdown"),
    created_issues:,
    plan_actions:,
    dry_run:,
    idempotent:,
    project_client: project_client,
    project_node_id: project_node_id,
    org: org,
    repo: repo
  )

  plan_actions << { "add_sub_issue" => "Epic -> Feature" }
  github.add_sub_issue(parent_issue_number: epic_issue.fetch("number"), child_issue_id: feature_issue.fetch("id")) unless dry_run

  # --- Assignee mapping logic ---
assignees_env_file = ENV["TP_TO_GITHUB_ASSIGNEE_MAPPING_FILE"]
assignee_mapping = TpToGithub::AssigneeMapping.from_file(assignees_env_file)
assignments = tp.assignments_for_user_story(story_id: story_id)
tp_emails = assignments.map { |as| as.dig("GeneralUser", "Login") }.compact.uniq
story_assignees = TpToGithub::AssigneeUtils.map_tp_emails_to_gh_usernames(tp_emails, assignee_mapping, warn_io: $stderr)

story_issue = create_or_find_issue(
    github:,
    tp_type: "UserStory",
    tp_id: story_id,
    title: normalized_story.fetch("name"),
    body: normalized_story.fetch("description_markdown"),
    created_issues:,
    plan_actions:,
    dry_run:,
    idempotent:,
    project_client: project_client,
    project_node_id: project_node_id,
    org: org,
    repo: repo,
    assignees: story_assignees
  )

  # Set Estimate field from TP Effort (if present)
  tp_effort = story["Effort"]
  if !tp_effort.nil? && project_client && project_node_id && org && repo
    begin
      repo_name = repo.split("/").last
      issue_node = project_client.issue_node_id(owner: org, repo: repo_name, number: story_issue["number"])
      # Use the add_to_project mutation result (should be the item_id)
      item_id = story_issue["project_item_id"] || begin
        # fallback if not present (should not happen for new items)
        project_client.find_project_item_id(project_node_id: project_node_id, issue_node_id: issue_node)
      end
      fields = project_client.project_fields(project_node_id: project_node_id)
      matches = fields.select { |f| f["name"] == "Estimate" && f["dataType"] == "NUMBER" }
      if matches.empty?
        raise "No project field named 'Estimate' of type NUMBER found"
      elsif matches.size > 1
        raise "Multiple 'Estimate' fields found, will not set value (ambiguous)"
      end
      field_id = matches.first["id"]
      if dry_run
        plan_actions << { "set_project_estimate" => { "item_id" => item_id, "field_id" => field_id, "value" => tp_effort } }
      else
        project_client.set_estimate_field(project_node_id: project_node_id, item_id: item_id, field_id: field_id, value: tp_effort)
        plan_actions << { "set_project_estimate" => { "item_id" => item_id, "field_id" => field_id, "value" => tp_effort } }
      end
    rescue => e
      plan_actions << { "set_project_estimate_error" => { "error" => e.message, "story_id" => story_id } }
      warn "[tp-to-github] Failed to set Estimate project field: #{e.message}"
    end
  end

  plan_actions << { "add_sub_issue" => "Feature -> Story" }
  github.add_sub_issue(parent_issue_number: feature_issue.fetch("number"), child_issue_id: story_issue.fetch("id")) unless dry_run

  # --- Set Status field on project item for story ---
  entity_state_hash = story["EntityState"]
  tp_status = entity_state_hash.is_a?(Hash) ? entity_state_hash["Name"].to_s.strip : entity_state_hash.to_s.strip
   STATUS_MAPPING = {
     "Open" => "Todo",
     "Specified" => "Todo",
     "Estimated" => "Todo",
     "Planned" => "Todo",
     "In Progress" => "In progress",
     "In Testing" => "In testing",
     "Awaiting Release" => "Awaiting release",
     "Done" => "Done",
     "Code Review" => "Code review"
   }
   # NOTE: Option IDs are no longer hardcoded. We query possible values dynamically.
   github_status = STATUS_MAPPING[tp_status]
   raise "Unknown or unmapped EntityState: #{tp_status.inspect}" unless github_status
   # Build runtime mapping StatusName => ID from the actual project's fields
   fields = project_client.project_fields(project_node_id: project_node_id)
   status_field = fields.find { |f| f["name"] == "Status" }
   unless status_field
     raise "Project 'Status' field not found"
   end
   # Find the options array, which is present for single select fields
   options = status_field["options"] || []
   status_name_to_id = options.each_with_object({}) { |opt, h| h[opt["name"]]=opt["id"] }
   option_id = status_name_to_id[github_status]
   raise "No option ID for status '#{github_status}'. Available: #{status_name_to_id.keys.inspect}" unless option_id

  if project_client && project_node_id && org && repo
    repo_name = repo.split("/").last
    issue_node = project_client.issue_node_id(owner: org, repo: repo_name, number: story_issue["number"])
    item_id = story_issue["project_item_id"]
    unless item_id
      warn "DEBUG: No project_item_id stored; falling back to find_project_item_id"
      item_id = project_client.find_project_item_id(project_node_id: project_node_id, issue_node_id: issue_node)
    end
    raise "Could not determine project item id for story" unless item_id
    fields = project_client.project_fields(project_node_id: project_node_id)
    warn "DEBUG: All project field names and their raw objects:"
    fields.each { |f| warn "[#{f['name']}] #{f.inspect}" }
    status_field = fields.find { |f| f["name"] == "Status" }
    unless status_field
      raise "Project 'Status' field not found"
    end
    require 'pp'; pp status_field
   # Use resolved (runtime) option_id by status name
   project_client.set_status_field(project_node_id: project_node_id, item_id: item_id, field_id: status_field["id"], option_id: option_id)
    plan_actions << { "set_status_field" => github_status }
  end

  if dry_run
    plan["github"]["actions"] = plan_actions
    puts JSON.pretty_generate(plan)
    exit 0
  end

  result = {
    "tp_story_id" => story_id,
    "tp_team_id" => team_id,
    "github_project_issue" => { "number" => project_issue["number"], "url" => project_issue["html_url"] },
    "github_epic_issue" => { "number" => epic_issue["number"], "url" => epic_issue["html_url"] },
    "github_feature_issue" => { "number" => feature_issue["number"], "url" => feature_issue["html_url"] },
    "github_story_issue" => { "number" => story_issue["number"], "url" => story_issue["html_url"] }
  }

  puts JSON.pretty_generate(result)
ensure
  created_issues.each do |issue|
    github.mute_issue(issue_number: issue.fetch("number"))
  rescue TpToGithub::GitHubClient::Error
    nil
  end
end
